<h2>Call stack</h2>
<div class="step-text">
<p>When you write a program, it probably contains several functions invoking each other, either programmer-defined or standard ones, and all of them need to be executed. How does the machine understand the order of the execution? How does it switch between different functions? How does it know when the program execution is over? To shed light on these questions we need to learn about a special data structure — a call stack.</p><h5 id="call-stack-structure">Call stack structure</h5><p>JVM uses a <strong>call stack</strong> (or <strong>execution stack</strong>) to understand which function should be invoked next and to access information regarding it. The call stack is composed of <strong>stack frames</strong> that store information about functions that have not yet terminated. The information includes the return address<em> </em>of a function, parameters, local variables, intermediate computations, and some other data.</p><p style="text-align: center;"><img alt="stack structure" height="133" src="https://ucarecdn.com/c2f77b5f-3e74-4d65-834e-a435045f9f99/" width="300"/></p><p>As a regular stack, the call stack follows the rule <strong>Last In First Out (LIFO)</strong>. It means stack frames are pushed at the top and move everything down. A new stack frame is added when the execution enters the new function. And the stack frame is removed from the call stack if the execution of a function is done.</p><h5 id="stack-frame-example">Stack frame example</h5><p>Let’s consider an example of a <strong>call stack</strong> for a program that prints the next even number of the given one. For simplicity, we will use the number 99 as the input.</p><p> </p><p></p><div class="alert alert-primary"><p>If you have forgotten or did not know, an <strong>even number</strong> is a number that is divisible by 2 and generates a remainder 0. Otherwise, a number is called <strong>odd</strong>.</p></div><p></p><p> </p><p>Here is the program:</p><pre><code class="language-kotlin">fun printNextEvenNumber(n: Int) {
    val next = if (n % 2 == 0) n + 2 else n + 1
    println(next)
}

fun main(args: Array&lt;String&gt;) {
    val n = 99
    printNextEvenNumber(n)
}</code></pre><p>The program declares two functions: <code class="language-kotlin">printNextEvenNumber</code> and <code class="language-kotlin">main</code>.</p><p>As usual, the first function to be invoked is <code class="language-kotlin">main</code>. Each time a function is invoked, a new stack frame is created. The stack frame for <code class="language-kotlin">main</code> is structured the following way:</p><ol><li><p>The function parameters (<code class="language-kotlin">args</code>) are pushed on the frame.</p></li><li><p>The function address (shown in the scheme as the function name — <code class="language-kotlin">main</code>) is added to the stack frame to keep a reference to where to return from the following function calls.</p></li><li><p>The local variables (<code class="language-kotlin">n</code>) are added to the frame.</p></li></ol><p>The picture below presents the resulting call stack with <code class="language-kotlin">main</code> stack frame within.</p><p style="text-align: center;"><img alt="the picture below presents the resulting call stack with main stack frame within" height="1733" src="https://ucarecdn.com/1123ed81-f2c8-4bf3-8411-e2cafaad0c0f/" width="1478"/></p><p> </p><p></p><div class="alert alert-warning"><p>Actually, the stack stores just a reference to the <code class="language-kotlin">args</code> array since all reference types are stored in heap memory. But, the stack stores the actual value of <code class="language-kotlin">n</code> (which is 99 in our example).</p></div><p></p><p> </p><h5 id="stack-and-functions-execution">Stack and functions execution</h5><p>The next function to be invoked is <code class="language-kotlin">printNextEvenNumber</code>. As always, a new stack frame is created. The function parameters (<code class="language-kotlin">n</code>), address (<code class="language-kotlin">printNextEvenNumber</code> for simplicity), and local variables (<code class="language-kotlin">next</code>) are added to the new stack frame.</p><p>We have two complete stack frames for <code class="language-kotlin">main</code> and <code class="language-kotlin">printNextEvenNumber</code> functions within the execution stack:</p><p style="text-align: center;"><img alt="stack execution" height="1733" src="https://ucarecdn.com/7cc285a5-5d51-44b6-9b3e-9520439d8355/" width="1478"/></p><p> </p><p></p><div class="alert alert-primary"><p>Note, both frames have variables named <code class="language-kotlin">n</code>, but these variables are not the same since they belong to different functions.</p></div><p></p><p> </p><p>Now the program executes the function at the top of the call stack (<code class="language-kotlin">printNextEvenNumber</code>). After the execution, the current frame <code class="language-kotlin">printNextEvenNumber</code> is removed from the call stack and the previous frame <code class="language-kotlin">main</code> continues the execution.</p><p style="text-align: center;"><img alt="example of executing a function at the top of the call stack" height="1733" src="https://ucarecdn.com/ae6df2f3-9be1-4992-9b4f-8d354e28741e/" width="1478"/></p><p>The standard function <code class="language-kotlin">println</code> works in a similar way as the functions we have defined — the new stack frame is created and when <code class="language-kotlin">println</code> finishes its work, the <code class="language-kotlin">printNextEvenNumber</code> continues the execution.</p><p>Any Kotlin or Java program works almost in this way. When the stack is empty, the execution stops. We skip some details to simplify the explanation and give you only the general view.</p><h5 id="stack-overflow">Stack overflow</h5><p>The number of possible function invocations depends on the amount of memory allocated to the stack. When your stack contains too many stack frames, it can be overflowed. It leads to the <code class="language-kotlin">StackOverflowError</code> that will stop the execution. The stack size can be set with the command line option <code class="language-kotlin">-Xss</code> for executing a particular program:</p><pre><code class="language-kotlin">kotlin YourProgramName -Xss256k</code></pre><p>But we recommend you to be careful with it and read some articles on the Internet before modifying the default stack size. Also, sometimes the <code class="language-kotlin">StackOverflowError</code> points to an incorrect recursion call in your program. In this case, increasing the size of the stack will not help you.</p><h5 id="conclusion">Conclusion</h5><ul><li><p>A call stack is a special data structure, following the LIFO rule, used by JVM to define functions execution order and to access functions information.</p></li><li><p>A call stack consists of stack frames — stacks containing information about functions that were called and have not yet finished their execution.</p></li><li><p>The machine executes the functions on top of the call stack. If this function calls the new one, then the new stack frame is added to the call stack, and the execution goes to this new function, and so on. When the top function finishes the execution, the corresponding stack frame is removed from the call stack, and the execution goes to the next top function.</p></li><li><p>Call stack containing too many stack frames may lead to <code class="language-kotlin">StackOverflowError</code>. Thus, you need to be careful using recursive calls in your program.</p></li></ul>
</div>
